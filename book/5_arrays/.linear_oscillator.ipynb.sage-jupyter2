{"backend_state":"init","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"trust":true,"type":"settings"}
{"cell_type":"code","exec_count":0,"id":"c9fa8d","input":"","pos":9,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"47aee0","input":"import matplotlib.pyplot as plt\nimport numpy as np\n\nt_max = 40\ndelta_t = 0.001 # time step is 1 ms\nk = 0.1\nm = 0.1","pos":1,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"eb755b","input":"t = np.arange(0, t_max, delta_t) # array of time points from 0 to t_max\n\nn_steps = len(t)\n\nx = np.zeros(n_steps)\nv = np.zeros(n_steps)\n\nx[0] = 0.1 # initial displacement\nv[0] = 0 # initial velocity","pos":3,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"72b682","input":"for i in range(n_steps - 1):\n    x[i+1] = x[i] + v[i] * delta_t\n    v[i+1] = v[i] - (k/m)*x[i]*delta_t","pos":5,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"52911a","input":"# Note the rather complicated method for setting up the plots\n# So that we can have a single legend but separate axes for displacement\n# and velocity\n\nfig = plt.figure(figsize=(8, 3))\nax = fig.add_subplot()\nax.plot(t, x, ls=\"-\", label=\"x\")\nax.set_ylabel(\"displacement (m)\")\nax.set_xlabel(\"time (s)\")\nax_r = ax.twinx() # allows us to have separate y-axes on left and right\nax_r.plot(t, v, ls=\":\", label=\"v\")\nax_r.set_ylabel(\"velocity (m/s)\")\nfig.legend()","output":{"0":{"data":{"text/plain":"<matplotlib.legend.Legend at 0x7fa61e5d7be0>"},"exec_count":4,"output_type":"execute_result"},"1":{"data":{"image/png":"0ad973584973a47b831313d0d28a1a8fec82007e","text/plain":"<Figure size 576x216 with 2 Axes>"},"exec_count":4,"metadata":{"image/png":{"height":228,"width":564},"needs_background":"light"},"output_type":"execute_result"}},"pos":7,"type":"cell"}
{"cell_type":"markdown","id":"3f33e4","input":"Finally we can plot the position and velocity on the same graph:","pos":6,"type":"cell"}
{"cell_type":"markdown","id":"69daaf","input":"## Example: Linear Oscillator\n\nNewton's law states that the acceleration of a mass is proportional the force applied to it:\n\n$$F = m\\ddot{x}$$\n\nwhere $F$ is force, $m$ is mass and $\\ddot{x}$ is the second derivative of particle displacement.\n\nSuppose we have a mass attached to a spring. Then Hooke's law states that the force on the mass is proportional to displacement $x$, measured from its equilibrium position:\n\n$$F = -kx$$\n\nThe minus sign represents the fact that the force acts in the opposite direction to the displacement.\n\nCombining the two equations and setting velocity $v = \\dot{x}$ we arrive at the following set of coupled equations:\n\n$$ \\begin{align*}\n\\frac{dx}{dt} &= v\\\\\n\\frac{dv}{dt} &= (-k/m)x\n\\end{align*}$$\n\nTo solve these equations numerically, we will split time into discrete timesteps $\\Delta t$, and calculate the approximate change in $x$ and $v$ at each timestep:\n\n$$ \\begin{align*}\n\\frac{\\Delta x}{\\Delta t} &= v\\\\\n\\frac{\\Delta v}{\\Delta t} &= (-k/m)x\n\\end{align*}$$\n\nFinally, using $x_i$ and $v_i$ to represent the value of displacement and velocity at timestep $i$:\n\n$$ \\begin{align*}\nx_{i+1} &= x_i + v_i\\Delta t\\\\\nv_{i+1} &= v_i + (-k/m)x_i\\Delta t\n\\end{align*}$$\n\nUsing this form of equations we can **numerically integrate** the system from a given **initial condition** $x_0, v_0$.\n\nGiven one-dimensional numpy arrays `x` and `v` representing the displacement and velocity respectively, we can use the equations above to calculate the values of `x[i+1]` and `v[i+1]` given `x[i]` and `v[i]`.\n\n```\nx[i+1] = x[i] + v[i] * delta_t\nv[i+1] = v[i] - (k/m)*x[i]*delta_t\n```\n\nFirst we import the necessary libraries and set the values of the timestep `delta_t`, upper time limit `t_max`, spring constant `k` and mass `m`.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"86023c","input":"Next, we create an array of timepoints `t` and arrays of the same length `x` and `v`. `x` and `v` are initially zero, except for the first elements which are set to the initial displacement and velocity.","pos":2,"type":"cell"}
{"cell_type":"markdown","id":"a34538","input":":::{note}\n**Forward Euler Method**\n\nThis method of integrating differential equations is called the Forward Euler method. Faster and more accurate methods are also the available, such as the Runga-Kutta method. A variety of methods can be accessed by importing `scipy.integrate.odeint`.\n:::\n\n","pos":8,"type":"cell"}
{"cell_type":"markdown","id":"d92b64","input":"The main step is to integrate the equations using the expressions derived above. We loop over all the time steps, calculating the position and velocity each step:","pos":4,"type":"cell"}
{"last_load":1636847100636,"type":"file"}
{"backend_state":"init","kernel":"python3","kernel_state":"idle","kernel_usage":{"cpu":0,"memory":0},"metadata":{"language_info":{"codemirror_mode":{"name":"ipython","version":3},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython3","version":"3.8.10"}},"trust":false,"type":"settings"}
{"cell_type":"code","exec_count":1,"id":"101881","input":"import matplotlib.image as mpimg # import the image module\n\nx = mpimg.imread(\"bw.png\") # read the image into an array\n\nprint(\"shape:\", x.shape)","output":{"0":{"name":"stdout","output_type":"stream","text":"shape: (8, 8, 4)\n"}},"pos":15,"type":"cell"}
{"cell_type":"code","exec_count":1,"id":"643db9","input":"import numpy as np\n\na = np.zeros((3, 4))\nprint(a)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]]\n"}},"pos":2,"type":"cell"}
{"cell_type":"code","exec_count":10,"id":"6cfa7c","input":"import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.image as mpimg # import the image module\n\nx = mpimg.imread(\"bw.png\") # read the image into an array\nplt.figure(figsize=(4,4))\nplt.imshow(x)\n","output":{"0":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f1b93dcce50>"},"exec_count":10,"output_type":"execute_result"},"1":{"data":{"image/png":"d5552bde567ad6c6d3d80682f55730105eecf253","text/plain":"<Figure size 288x288 with 1 Axes>"},"exec_count":10,"metadata":{"image/png":{"height":248,"width":245},"needs_background":"light"},"output_type":"execute_result"}},"pos":22,"type":"cell"}
{"cell_type":"code","exec_count":11,"id":"4d9864","input":"print(\"Dimensions:\", x.shape)","output":{"0":{"name":"stdout","output_type":"stream","text":"Dimensions: (8, 8, 4)\n"}},"pos":24,"type":"cell"}
{"cell_type":"code","exec_count":12,"id":"ea9aa2","input":"z = np.sum(x, 2) # sum the RGBA values for each pixel\nprint(np.round(z, 1))","output":{"0":{"name":"stdout","output_type":"stream","text":"[[1.1 1.4 1.1 1.5 1.3 1.  1.2 1.1]\n [1.5 1.8 2.  2.1 1.8 1.2 1.2 1.1]\n [1.8 2.4 3.  3.2 2.3 1.7 1.4 1.2]\n [1.9 3.1 3.6 3.6 3.3 1.8 1.3 1.3]\n [2.  3.2 3.6 3.7 3.  2.  1.7 1.2]\n [1.8 2.3 3.  3.1 2.4 2.3 2.5 1.7]\n [1.4 1.9 2.  1.9 1.8 2.4 4.  2.3]\n [1.1 1.4 1.2 1.1 1.2 1.6 1.9 1.5]]\n"}},"pos":26,"type":"cell"}
{"cell_type":"code","exec_count":13,"id":"76e781","input":"print(\"Min:\", np.min(z))\nprint(\"Max:\", np.max(z))","output":{"0":{"name":"stdout","output_type":"stream","text":"Min: 1.0\nMax: 4.0\n"}},"pos":28,"type":"cell"}
{"cell_type":"code","exec_count":14,"id":"1c35ce","input":"thres = 2\nx_thres = z > thres # Determine pixels which are above the threshold\nprint(x_thres)\nplt.figure(figsize=(4,4))\nplt.imshow(x_thres) # Note that in Python True = 1 and False = 0","output":{"0":{"name":"stdout","output_type":"stream","text":"[[False False False False False False False False]\n [False False  True  True False False False False]\n [False  True  True  True  True False False False]\n [False  True  True  True  True False False False]\n [ True  True  True  True  True False False False]\n [False  True  True  True  True  True  True False]\n [False False False False False  True  True  True]\n [False False False False False False False False]]\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f1b91d30610>"},"exec_count":14,"output_type":"execute_result"},"2":{"data":{"image/png":"11498070a95ad383cc4730b50a1d07684fe80061","text/plain":"<Figure size 288x288 with 1 Axes>"},"exec_count":14,"metadata":{"image/png":{"height":248,"width":245},"needs_background":"light"},"output_type":"execute_result"}},"pos":30,"type":"cell"}
{"cell_type":"code","exec_count":15,"id":"d86f11","input":"thres = 2.5\nx_thres = z > thres # Determine pixels which are above the threshold\nprint(x_thres)\nplt.figure(figsize=(4,4))\nplt.imshow(x_thres) # Note that in Python True = 1 and False = 0","output":{"0":{"name":"stdout","output_type":"stream","text":"[[False False False False False False False False]\n [False False False False False False False False]\n [False False  True  True False False False False]\n [False  True  True  True  True False False False]\n [False  True  True  True  True False False False]\n [False False  True  True False False False False]\n [False False False False False False  True False]\n [False False False False False False False False]]\n"},"1":{"data":{"text/plain":"<matplotlib.image.AxesImage at 0x7f1b91d13640>"},"exec_count":15,"output_type":"execute_result"},"2":{"data":{"image/png":"87efdc73e5216eff4a3a1e0543a14fdc459f6b9f","text/plain":"<Figure size 288x288 with 1 Axes>"},"exec_count":15,"metadata":{"image/png":{"height":248,"width":245},"needs_background":"light"},"output_type":"execute_result"}},"pos":32,"type":"cell"}
{"cell_type":"code","exec_count":16,"id":"9ab56a","input":"import scipy.ndimage as sn # import the scipy.ndimage package\nx_labels, n = sn.label(x_thres) # generate \nprint(\"number of blobs:\", n)\nprint(x_labels)","output":{"0":{"name":"stdout","output_type":"stream","text":"number of blobs: 2\n[[0 0 0 0 0 0 0 0]\n [0 0 0 0 0 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 1 1 1 1 0 0 0]\n [0 0 1 1 0 0 0 0]\n [0 0 0 0 0 0 2 0]\n [0 0 0 0 0 0 0 0]]\n"}},"pos":34,"type":"cell"}
{"cell_type":"code","exec_count":17,"id":"19e743","input":"sizes = sn.sum(x_thres, x_labels, range(1, n+1))\nprint(\"sizes:\", sizes)","output":{"0":{"name":"stdout","output_type":"stream","text":"sizes: [12.  1.]\n"}},"pos":36,"type":"cell"}
{"cell_type":"code","exec_count":18,"id":"dbdbad","input":"idx = np.argmax(sizes) # get the index of the largest blob\nprint(\"index:\", idx)","output":{"0":{"name":"stdout","output_type":"stream","text":"index: 0\n"}},"pos":38,"type":"cell"}
{"cell_type":"code","exec_count":19,"id":"f59e56","input":"location = sn.center_of_mass(x_thres, x_labels, idx + 1) # determine the coordinates of the largest blob\nprint(\"location:\", location)","output":{"0":{"name":"stdout","output_type":"stream","text":"location: (3.5, 2.5)\n"}},"pos":40,"type":"cell"}
{"cell_type":"code","exec_count":2,"id":"35b3fa","input":"x = np.arange(0, 4)\nrow1 = 2 ** x\nprint(row1)\nrow2 = 3 ** x\nprint(row2)\nrow3 = 4 ** x\nprint(row3)","output":{"0":{"name":"stdout","output_type":"stream","text":"[1 2 4 8]\n[ 1  3  9 27]\n[ 1  4 16 64]\n"}},"pos":4,"type":"cell"}
{"cell_type":"code","exec_count":20,"id":"06fb96","input":"plt.figure(figsize=(4,4))\nplt.imshow(x)\n# arrays are indexed [column, row] whereas scatter plots are ordered [x, y]\n# so we need to reverse the order of the indices\nplt.scatter(location[1], location[0])","output":{"0":{"data":{"text/plain":"<matplotlib.collections.PathCollection at 0x7f1b84306c70>"},"exec_count":20,"output_type":"execute_result"},"1":{"data":{"image/png":"fec8ec614906b8a21d35b5d16dbb1609787604a3","text/plain":"<Figure size 288x288 with 1 Axes>"},"exec_count":20,"metadata":{"image/png":{"height":248,"width":245},"needs_background":"light"},"output_type":"execute_result"}},"pos":43,"type":"cell"}
{"cell_type":"code","exec_count":3,"id":"a0bdd7","input":"a[0, :] = row1\na[1,:] = row2\na[2,:] = row3\n\nprint(a)","output":{"0":{"name":"stdout","output_type":"stream","text":"[[ 1.  2.  4.  8.]\n [ 1.  3.  9. 27.]\n [ 1.  4. 16. 64.]]\n"}},"pos":6,"type":"cell"}
{"cell_type":"code","exec_count":4,"id":"8c24e6","input":"s = a.shape\nprint(s)\n\nx = s[0]\ny = s[1]\n\nprint(\"first dimension:\", x)\nprint(\"second dimension:\", y)","output":{"0":{"name":"stdout","output_type":"stream","text":"(3, 4)\nfirst dimension: 3\nsecond dimension: 4\n"}},"pos":8,"type":"cell"}
{"cell_type":"code","exec_count":5,"id":"eb7bf3","input":"sum_of_rows = np.sum(a, axis=0)\nprint(sum_of_rows)","output":{"0":{"name":"stdout","output_type":"stream","text":"[ 3.  9. 29. 99.]\n"}},"pos":10,"scrolled":true,"type":"cell"}
{"cell_type":"code","exec_count":6,"id":"7463a1","input":"sum_of_columns = np.sum(a, axis=1)\nprint(sum_of_columns)","output":{"0":{"name":"stdout","output_type":"stream","text":"[15. 40. 85.]\n"}},"pos":12,"type":"cell"}
{"cell_type":"code","exec_count":8,"id":"029725","input":"print(x[0, 0, :])","output":{"0":{"name":"stdout","output_type":"stream","text":"[0.02352941 0.02352941 0.02352941 1.        ]\n"}},"pos":17,"type":"cell"}
{"cell_type":"code","exec_count":9,"id":"2bf195","input":"z = np.sum(x, axis=2)\nprint(np.round(z, 1))","output":{"0":{"name":"stdout","output_type":"stream","text":"[[1.1 1.4 1.1 1.5 1.3 1.  1.2 1.1]\n [1.5 1.8 2.  2.1 1.8 1.2 1.2 1.1]\n [1.8 2.4 3.  3.2 2.3 1.7 1.4 1.2]\n [1.9 3.1 3.6 3.6 3.3 1.8 1.3 1.3]\n [2.  3.2 3.6 3.7 3.  2.  1.7 1.2]\n [1.8 2.3 3.  3.1 2.4 2.3 2.5 1.7]\n [1.4 1.9 2.  1.9 1.8 2.4 4.  2.3]\n [1.1 1.4 1.2 1.1 1.2 1.6 1.9 1.5]]\n"}},"pos":19,"type":"cell"}
{"cell_type":"markdown","id":"0a5726","input":"## More Array Functions\n\nFirst we look at another method of constructing 2d arrays, by constructing one row at a time. Suppose we want to create the following array, where the first row is powers of 2, the second row is powers of 3, and so on:\n\n$$\\begin{matrix}\n1 & 2 & 4 & 8 \\\\\n1 & 3 & 9 & 27 \\\\\n1 & 4 & 16 & 64\n\\end{matrix}$$\nWe create a zero array of the desired dimensions using the function `np.zeros`:","pos":1,"type":"cell"}
{"cell_type":"markdown","id":"1639f8","input":"Other methods that take the `axis` parameter include `np.max` and `np.mean`.","pos":13,"type":"cell"}
{"cell_type":"markdown","id":"16af32","input":"This method has performed the vector sum of the rows of `a`, `[1, 2, 4, 8] + [1, 3, 9, 27] + [1, 4, 16, 64]`. Element `i` of the result is the sum down the column `i` of `a`. The parameter `axis=0` determines that it is the 1st (counting from 0) dimension that should be aggregated.\n\nTo perform the aggregation along the second dimension, use `axis=1`.","pos":11,"type":"cell"}
{"cell_type":"markdown","id":"197bc1","input":"The threshold must lie between 1 and 4. Let's try a value of 2.","pos":29,"type":"cell"}
{"cell_type":"markdown","id":"230926","input":"Note that the indexes of the `sizes` array are counted from 0 to n-1, whereas the labels are counted from 1 to n, so index `idx` corresponds to the blob with label `idx + 1`.  \nNext we determine the location of the largest blob using the `sn.center_of_mass` function, which returns the co-ordinates of the centre of a blob. ","pos":39,"type":"cell"}
{"cell_type":"markdown","id":"247a98","input":"Notice the double brackets, which are necessary because the function `np.zeros` takes a tuple as a parameter.\n\nNext, we create each of the individual rows as 1 x 4 arrays:","pos":3,"type":"cell"}
{"cell_type":"markdown","id":"24b993","input":"### Reduce to greyscale","pos":23,"type":"cell"}
{"cell_type":"markdown","id":"3a1728","input":"This is a three dimensional array where `x[i,j,0]` is the R value, `x[i,j,1]` is the G value, `x[i,j,2]` is the B value and `x[i,j,3]` is the alpha (transparency) value. `x[0, 0, :]` extracts all four values for the (0, 0) pixel as a 1 x 4 array:","pos":16,"type":"cell"}
{"cell_type":"markdown","id":"506338","input":"In this week's exercises you will repeat this procedure using a sequence of real experimental images of particles exhibiting Brownian motion.","pos":44,"type":"cell"}
{"cell_type":"markdown","id":"5371d6","input":"```{note}  \nThe `location` variable is a `tuple`. A tuple is the same as a list, and we use the same square bracket notation to access elements, such as `location[0]`. But:\n- When defining a tuple we use round brackets `()` instead of square brackets `[]`. `location = (1, 4)`.\n- A tuple is **immutable**, meaning its elements cannot be changed. `location[0] = 5` results in an error.\n```","pos":41,"type":"cell"}
{"cell_type":"markdown","id":"5ab06d","input":"### Read the Image File","pos":21,"type":"cell"}
{"cell_type":"markdown","id":"5d15d4","input":"Next, use the `sn.sum` function to generate an array containing the size (in number of pixels) of each blob.","pos":35,"type":"cell"}
{"cell_type":"markdown","id":"6f5dd7","input":"Finally, we assign each row to the correct row in `a` using slice notation:","pos":5,"type":"cell"}
{"cell_type":"markdown","id":"719d2a","input":"### Axis Methods\nThe method `np.sum` allows us to calculate the sum of the elements in an array. If your array is 2-dimensional, it is often useful to calculate the sum in one dimension only, to return a 1-dimensional array. This can be achieved using the `axis` parameter of the `sum` function:","pos":9,"type":"cell"}
{"cell_type":"markdown","id":"7450c6","input":"We would like to identify the largest blob (the top left one). We will increase the value of `thres` so that there are two distinct blobs in the thresholded image. ","pos":31,"type":"cell"}
{"cell_type":"markdown","id":"823178","input":"### Tresholding\nThe next step is to classify each pixel as 'foreground' (belonging to a particle) or 'background'. We do this by setting each pixel to 1 if it is above a threshold value, and 0 otherwise. But what threshold value should we choose? It certainly must lie between the minimum and maximum values of the array.","pos":27,"type":"cell"}
{"cell_type":"markdown","id":"9c5c61","input":"Finally we will mark the location of the centre of the largest blob using `plt.scatter`. Arrays indices are ordered *row* then *column* which is opposite to x-y ordering for the scatter plot, so we have to reverse the ordering of the `location` elements when plotting. ","pos":42,"type":"cell"}
{"cell_type":"markdown","id":"bed5e8","input":"So blob 1 has 9 pixels and blob 2 has 1 pixel.\n`np.argmax` returns the index of the largest blob:","pos":37,"type":"cell"}
{"cell_type":"markdown","id":"bf8918","input":"### Blob Location\nThe next step is the determine the location of the largest identified blob. Fortunately there are functions available in the `scipy.ndimage` package which do just that. First, use the function `label` to generate an array in which  each element is a number identifying which connected blob the pixel belongs to. In this case, there are two blobs, so every pixel is labelled 1 or 2 if it belongs to one of the blobs, or 0 if it belongs to neither.","pos":33,"type":"cell"}
{"cell_type":"markdown","id":"c96054","input":"## Images\nAn image file is essentially a 3-dimensional array where each element represents colour intensity of each pixel. The first two dimensions correspond to the x and y co-ordinates of each pixel, and the third dimension corresponds to its RGBA value (R=red, G=Green, B=Blue and A=alpha which encodes transparency).\n\nThe file `bw.png` is an 8 by 8 pixel image (<a href=\"../tutorial_7/bw.png\" download>download</a>):\n\n![](bw_big.png)\n\nFirst we import the module `matplotlib.image` and use the `imread` function to convert it to an array.","pos":14,"type":"cell"}
{"cell_type":"markdown","id":"d66d07","input":"# Image Processing\nThis tutorial will examine how to use Python and Numpy to process images, which can be expressed as 2 or 3 dimensional arrays.","pos":0,"type":"cell"}
{"cell_type":"markdown","id":"e74f68","input":"## Particle Tracking\n\nMany scientific experiments require the capture of mages, for example  microscopic images of biological tissue slices, or photographs of astronomical objects images. Computers enable us to automate many of the processes associated with analysing such images, such as the automatic segmentation and labelling of cells in a tissue slice or identification of astronomical objects.  \n\nWe will be using Python image processing techniques to reproduce part of a famous experiment: Perrin's experiment to measure Avogadro's Number. In this experiment, images of tiny particles are recorded through a microscope.\n\nThis lesson is based in part on [an assignment from Princeton University](https://introcs.cs.princeton.edu/java/assignments/atomic.html) and you are encouraged to read it for reference.\n\n1. Read in an image file and convert it to a `numpy` array.\n1. Convert the array to greyscale by averaging along the last dimension\n1. Classify the pixels as foreground or background\n1. Find the particle locations\n1. Repeat for all images and plot a graph of particle location against time\n","pos":20,"type":"cell"}
{"cell_type":"markdown","id":"eb06a9","input":"### `shape` Method\n\nGiven an array, we can determine its dimensions using the `shape` method, which returns a tuple:","pos":7,"type":"cell"}
{"cell_type":"markdown","id":"f39096","input":"This is a greyscale image, so all the colour values are identical and the alpha value is 1 (100% opaque). We can aggregate along the third (number 2) axis to sum the colour values and return a 2-dimensional array. (The round function is used to make the printed array easier to read by reducing the number of decimal places displayed).","pos":18,"type":"cell"}
{"cell_type":"markdown","id":"fae99c","input":"We will reduce the array to 2-dimensions by summing the last dimension:","pos":25,"type":"cell"}
{"id":0,"time":1638122601225,"type":"user"}
{"last_load":1638121571883,"type":"file"}